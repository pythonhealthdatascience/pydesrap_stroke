# Changes from the HSMA model

This template model is based on a few sources - including: Sammi Rosser and Dan Chalk (2024) HSMA - the little book of DES (https://github.com/hsma-programme/hsma6_des_book) (MIT Licence).

This page explains some of the differences between the models in the HSMA book, and this template.

## Saving patient-level results

In the HSMA models, patient-level results are typically generated by first initialising an empty dataframe within the __init__ method of the `Model()` class:

```
self.results_df = pd.DataFrame()
self.results_df["Patient ID"] = [1]
self.results_df["Q Time Nurse"] = [0.0]
self.results_df["Time with Nurse"] = [0.0]
self.results_df.set_index("Patient ID", inplace=True)
```

The results of each patient are appended to this dataframe in during the `attend_clinic()` process:

```
self.results_df.at[patient.id, "Q Time Nurse"] = (
    patient.q_time_nurse)
self.results_df.at[patient.id, "Time with Nurse"] = (
    sampled_nurse_act_time)
```

This has been altered, as this process only saves results after patients have received a nurse resource, and so fails to record patients who enter the system and wait for the nurse, but are not seen before the simulation ends.

The alteration also allows for simplification of how the results dataframe is generated, without the need to define an empty dataframe with dummy data (as above), which is later removed.

The alteration involves creating a list called `patients` within the __init__ method of the `Model()` class. When each patient is created, they are add to this list. Their results are saved as attributes to the patient class. As the list refers to instances of each object, any updates to the patient attributes later on (such as when receive a wait time after having queued for the nurse) will also be reflected in the list. This list of objects is converted into a list of dictionaries after the simulation ends.

```
self.patients = []

...

p = Patient(len(self.patients) + 1)
p.arrival_time = self.env.now
if self.env.now >= self.param.warm_up_period:
    self.patients.append(p)


...

self.results_list = [x.__dict__ for x in self.patients]
```

The list `patients` is similar to the `patient_list` created in the HSMA model variant where variable arrival rates are modelled, except in that code, the list is only used for arrival rates and not for saving results.

## Initialise patients with `np.nan`

In the HSMA models, patients are initialised with values of 0 for each metric.

```
class Patient:
    def __init__(self, p_id):
        self.id = p_id
        self.q_time_nurse = 0
```

However, when viewing the patient-level results after the simulation, this means it is not possible to distinguish, for example, between a 0 indicating that a patient had no wait time, and a 0 indicating that a patient waited a long time but was never seen.

To resolve this issue, the metrics have instead been initialised with NaN values.

```
class Patient:
    def __init__(self, patient_id):
        self.patient_id = patient_id
        self.arrival_time = np.nan
        self.q_time_nurse = np.nan
        self.time_with_nurse = np.nan
```

This enables metrics like `count_nurse_unseen` and `mean_q_time_nurse_unseen`, which can show backlog in the system at the end of the simulation.

## Seeds

The HSMA models use a multiplied version of the `run_number` as a seed when sampling:

```
self.patient_inter_arrival_dist = Exponential(mean = g.patient_inter, random_seed = self.run_number*2)
self.nurse_consult_time_dist = Exponential(mean = g.mean_n_consult_time, random_seed = self.run_number*4)
```

In the template, the `run_number` is used as the entropy value for `np.random.SeedSequence()`, essentially acting like a "starter seed". This object can then be used to generate new seeds, for which the:

* Seeds are likely to have different initial states for the random number generator
* Streams are likely independent of each other

These are desirable properties, which we can't guarantee if we had just chosen a set of seeds for each ourselves.

```
ss = np.random.SeedSequence(entropy=self.run_number)
seeds = ss.spawn(2)
```

## Use of parameter class

In the HSMA models, the `g` class is used to store global parameter values. Rather than creating an instance of this class, the parameters are accessed and modified directly through the class itself. However, once changed, there is no way to revert to the original default values without re-importing or re-defining the class.

```
class g:
    patient_inter = 5
    mean_n_consult_time = 6
    number_of_nurses = 1
    sim_duration = 120
    number_of_runs = 5

...

g.patient_inter = 10
```

To resolve this, the template creates an instance of the parameter class, and never uses or alters it directly. For clarity, the class is called `Param()` and instances are typically called `param`.

```
class Param:
    """
    Default parameters for simulation.

    Attributes are described in initialisation docstring.
    """
    def __init__(
        self,
        patient_inter=4,
        mean_n_consult_time=10,
        number_of_nurses=5,
        warm_up_period=1440*13,
        data_collection_period=1440*30,
        number_of_runs=31,
        audit_interval=120,  # every 2 hours
        scenario_name=0,
        cores=-1,
        logger=SimLogger(log_to_console=False, log_to_file=False)
    ):
    ...

param = Defaults(patient_inter = 10)
model = Model(param)
```

## Saving replication results

To save results from each run in the HSMA models, an empty dataframe is initialised during the __init__ method of the `Trial` class (equivalent to the `Runner` class in this template).

```
self.df_trial_results = pd.DataFrame()
self.df_trial_results["Run Number"] = [0]
self.df_trial_results["Mean Q Time Nurse"] = [0.0]
self.df_trial_results.set_index("Run Number", inplace=True)
```

The results are calculated by `calculate_run_results()` in the `Model` class.

```
def calculate_run_results(self):
    self.mean_q_time_nurse = self.results_df["Q Time Nurse"].mean()
```

Results are then appended to the dataframe as each run is completed in a loop:

```
self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]
```

In the template, results are instead saved as a dictionary into a list as the runs are completed in a loop, and this is later converted into a dataframe. This approach:

* Avoids initialising an empty dataframe.
* Is consistent with how the patient-level results were also generated in the template.

Also, some of the calculations have been performed directly during the `run_single()` method, instead of from a seperate method `calculate_run_results()`. This is to help simplify the code, as it makes clear how each metric was calculated in one place, rather than needing to refer elsewhere.

```
run_results = {
    'run_number': run,
    'scenario': self.param.scenario_name,
    'arrivals': len(patient_results),
    'mean_q_time_nurse': patient_results['q_time_nurse'].mean(),
    'average_nurse_utilisation': (model.nurse_time_used /
                                    (self.param.number_of_nurses *
                                    self.param.data_collection_period))
}

...

self.run_results_df = pd.DataFrame(run_results_list)
```

### First arrival at time 0

In the HSMA model, there will always be an arrival at time 0, since that is the first action in `generator_patient_arrivals()`:

```
def generator_patient_arrivals(self):
    while True:
        self.patient_counter += 1
        p = Patient(self.patient_counter)
        sampled_inter = random.expovariate(1.0 / g.patient_inter)
        yield self.env.timeout(sampled_inter)
```

This has been altered, so the first patient arrives after a sampled inter-arrival time, by moving the sampling to the start of the method.

```
def generate_patient_arrivals(self):
    while True:
        sampled_inter = self.patient_inter_arrival_dist.sample()
        yield self.env.timeout(sampled_inter)
        p = Patient(len(self.patients) + 1)
        p.arrival_time = self.env.now
        ...
```

### MonitoredResource and warm-up

The same metrics can be calculated in several possible ways. In this model, time-weighted averages have been included using the `MonitoredResource`. This requires methods `init_results_variables()` and `warm_up_complete()`, which have meant that implementation of warm-up can be done using `warm_up_complete()` rather than by checking whether warm up is complete every time a metric is saved.

```
def warm_up_complete(self):
    if self.param.warm_up_period > 0:
        yield self.env.timeout(self.param.warm_up_period)
        self.init_results_variables()
```

As opposed to, for example:

```
if self.env.now > g.warm_up_period:
    self.results_df.at[patient.id, "Q Time Nurse"] = (
        patient.q_time_nurse
    )
```

## Corrections to the time with the resource

In the HSMA model, `time_with_nurse` is used for tracking resource utilisation. We include this approach, but with two corrections.

**Correction #1**: Towards the end of the simulation, simply recording the sampled time with the nurse will overestimate utilisation, if this would go beyond the simulation end. In which case, we save either the time with the nurse, or the time remaining in the simulation - whichever is smallest.

```
remaining_time = (
    self.param.warm_up_period +
    self.param.data_collection_period) - self.env.now
self.nurse_time_used += min(
    patient.time_with_nurse, remaining_time)
```

**Correction #2**: If a warm-up period is included, the utilisation will be underestimated, as it won't include patients who start their consultation with the nurse in the warm-up and finish it in the data collection period. In these cases, we use an attribute `nurse_time_used_correction` to record the time that would fall in the data collection period, and add this to the `time_with_nurse`.

```
remaining_warmup = self.param.warm_up_period - self.env.now
if remaining_warmup > 0:
    time_exceeding_warmup = (patient.time_with_nurse -
                                remaining_warmup)
    if time_exceeding_warmup > 0:
        self.nurse_time_used_correction += min(
            time_exceeding_warmup,
            self.param.data_collection_period)

...

# When resetting values after warm-up end...
self.nurse_time_used += self.nurse_time_used_correction
```

## Extra features

### Prevent addition of new attributes to the parameter class

The parameter class includes a function that:

* Allows existing attributes to be modified
* Prevents new attributes from being created

This is to avoid an error where it looks like a parameter has been changed, but actually the wrong attribute name was used - for example, setting `param.nurses = 3` and thinking this has reduced the number of nurse resources, but actually this is based on `param.number_of_nurses` which remains set to 9.

```
class Param():
    ...

    def __setattr__(self, name, value):
        if hasattr(self, '_initialising') and self._initialising:
            super().__setattr__(name, value)
        else:
            if name in self.__dict__:
                super().__setattr__(name, value)
            else:
                raise AttributeError(
                    f'Cannot add new attribute "{name}" - only possible to ' +
                    f'modify existing attributes: {self.__dict__.keys()}')

```

### Validation of inputs

The model class includes some code to check whether inputs to the model are valid. This is important as invalid inputs can cause run errors - for example, if `audit_interval` is set to 0, the model would run for eternity!

``` by simpy.Resource
validation_rules = {
    'positive': ['patient_inter', 'mean_n_consult_time',
                    'number_of_runs', 'audit_interval'],
    'non_negative': ['warm_up_period', 'data_collection_period']
}
for rule, param_names in validation_rules.items():
    for param_name in param_names:
        # Get the value of the parameter by its name
        param_value = getattr(self.param, param_name)
        # Check if it meets the rules for that parameter
        if rule == 'positive' and param_value <= 0:
            raise ValueError(
                f'Parameter "{param_name}" must be greater than 0.'
            )
        elif rule == 'non_negative' and param_value < 0:
            raise ValueError(
                f'Parameter "{param_name}" must be greater than or ' +
                'equal to 0.'
            )
```

### Tests

The files `test_unittest_model.py`, `test_unittest_logger.py` and `test_backtest.py` include various tests which check the model is functioning as expected. For example, checking that:

* It is not possible to add new attributes to the parameter class.
* Invalid inputs to `Model()` return an `ValueError`.
* Results from the model (e.g. wait time, utilisation) are not negative.
* No results are recorded during any warm-up period.
* Adjusting parameters decreases wait time as expected.

### Summary statistics

The `summary_stats()` function is used to find the overall results from across the trials - so the mean, standard deviation and 95% confidence interval for each performance metric.

It can also be applied to other results dataframes if desired.

### Logger

The `SimLogger` class will generate logs which can be saved to a file or printed to a console. This includes information on when patients arrive and are seen. This can be helpful for understanding the simulation or when debugging.

### Selecting the length of the warm-up period

The `choosing_warmup.ipynb` notebook includes a function which can be used to help choose an appropriate length for the warm-up period.

### Selecting the number of replications to use

The `replications.py` contains various functions and classes which can be used to help choose an appropriate number of replications to run, as explored in `choosing_replications.ipynb`.

### Other minor changes

There are a few smaller changes to the model with minimal impact on function. These include:

* **Names** - for example, `Patient.id` was changed to `Patient.patient_id`, as the patient objects are used to create the patient-level results dataframe, and want "patient_id" as the column name. Also, `Trial` was changed to `Runner` with methods changed to e.g. `run_reps()`.
* **Comments and docstrings**
* **Removed `patient_counter`** - as can just use the length of the `patients` list now.
* **Interval audit** - records cumulative mean wait time, as well as utilisation.