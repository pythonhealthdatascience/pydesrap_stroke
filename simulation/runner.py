"""
Run multiple replications of the simulation.
"""

from collections import Counter
from joblib import Parallel, delayed, cpu_count
import pandas as pd

from simulation.model import Model


class Runner:
    """
    Manages simulation runs, either running the model once or multiple times
    (replications).
    """
    def __init__(self, param):
        """
        Parameters
        ----------
        param: Param
            Simulation parameters.
        """
        # Store model parameters
        self.param = param

    def get_occupancy_freq(self, audit_list, unit):
        """
        Count the frequency each occupancy level was observed at within the
        interval audit for the specified unit.

        Parameters
        ----------
        audit_list: list
            The audit list generated by Model.interval_audit()
        unit: str
            Name of unit ("asu", "rehab").

        Returns
        -------
        df: pd.DataFrame
            Dataframe with two columns: the number of beds ("beds") and the
            frequency this was observed in the audit ("freq").
        """
        # Get occupancy audit results
        occ_audit = pd.DataFrame(audit_list)

        # Get the frequency of each number of beds in the specified unit
        frequency = Counter(occ_audit[f"{unit}_occupancy"])

        # Fill in any gaps - find the maximum bed count, then create complete
        # dictionary include bed counts which were never observed
        min_bed_count = min(frequency.keys())
        max_bed_count = max(frequency.keys())
        complete_frequency = {i: frequency.get(i, 0)
                              for i in range(min_bed_count, max_bed_count + 1)}

        # Convert into a dataframe
        df = pd.DataFrame(
            complete_frequency.items(), columns=["beds", "freq"])

        # Calculate percentage, cumulative percentage and probability of delay
        df = self.calculate_occupancy_stats(df)

        return df

    def calculate_occupancy_stats(self, df):
        """
        Given the frequencies of each occupancy level, calculates:
        1. Percentage
        2. Cumulative percentage
        3. Probability of delay

        Parameters
        ----------
        df: pd.Dataframe
            Dataframe containing the frequency of each occupancy level
            (e.g. as output by get_occupancy_freq()).
        """
        # Add column with frequencies converted to proportions
        df["pct"] = df["freq"] / df["freq"].sum()

        # Add column with the cumulative percentage
        df["c_pct"] = df["pct"].cumsum()

        # Calculate the probability of delay
        df["prob_delay"] = df["pct"] / df["c_pct"]

        return df

    def run_single(self, run):
        """
        Execute a single run of the simulation and calculate the occupancy
        frequencies and probability of delay.
        """
        # Run the model
        model = Model(param=self.param, run_number=run)
        model.run()

        # Get occupancy frequencies for both units
        asu_occupancy = self.get_occupancy_freq(
            audit_list=model.audit_list, unit="asu")
        rehab_occupancy = self.get_occupancy_freq(
            audit_list=model.audit_list, unit="rehab")

        return {"asu": asu_occupancy, "rehab": rehab_occupancy}

    def run_reps(self):
        """
        Execute a single model configuration for multiple runs/replications.
        """
        # Sequential execution
        if self.param.cores == 1:
            results = [self.run_single(run)
                       for run in range(self.param.number_of_runs)]

        # Parallel execution
        else:

            # Check number of cores is valid
            valid_cores = [-1] + list(range(1, cpu_count()))
            if self.param.cores not in valid_cores:
                raise ValueError(
                    f"Invalid cores: {self.param.cores}. Must be one of: " +
                    f"{valid_cores}.")

            # Warn users that logging will not run as it is in parallel
            if (
                self.param.logger.log_to_console or
                self.param.logger.log_to_file
            ):
                self.param.logger.log(
                    "WARNING: Logging is disabled in parallel " +
                    "(multiprocessing mode). Simulation log will not appear." +
                    " If you wish to generate logs, switch to `cores=1`, or " +
                    "just run one replication with `run_single()`.")

            # Execute replications
            results = Parallel(n_jobs=self.param.cores)(
                delayed(self.run_single)(run)
                for run in range(self.param.number_of_runs))

        # Extract dataframes and add run column
        rep_dataframes = {"asu": [], "rehab": []}
        for i, entry in enumerate(results):
            for key in ["asu", "rehab"]:
                df_copy = entry[key].copy()
                df_copy["run"] = i
                rep_dataframes[key].append(df_copy)

        # Concatenate the ASU and rehab dataframes into a single dataframe each
        result = {key: pd.concat(dfs) for key, dfs in rep_dataframes.items()}

        # Create a summary dataframe for each unit with the overall frequency
        # and occupancy for each bed
        overall = {}
        for unit in ["asu", "rehab"]:
            # Sum the count the frequencies of beds across replications
            comb = (result[unit]
                    .groupby("beds", as_index=False)["freq"]
                    .sum())
            # Calculate percentage, cumulative percentage and probability of
            # delay, and save to dictionary
            overall[unit] = self.calculate_occupancy_stats(comb)

        return result, overall
